{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Lapangbola Python Documentation","text":"<p>Welcome to the Lapangbola Python Documentation! This documentation provides a collection of Python modules and functions designed to help and visualize football data. For full football stats visit live.lapangbola.com.</p>"},{"location":"preparation/dataframe/","title":"Create data frame from excel","text":"<p>All file's path and name are adjusted based on what you've got on your drive or storage</p>"},{"location":"preparation/dataframe/#data-frame-from-excel-report","title":"Data Frame from Excel Report","text":"<pre><code>#mount to gdrive\nfrom google.colab import drive\ndrive.mount('/content/gdrive', force_remount=True)\n\n#loading all the files\npath = '/content/gdrive/MyDrive/Data/Liga Indonesia 2024/Liga 1/Match'\nall_files = glob.glob(os.path.join(path, \"*.xlsx\"))\n\n#load all the files to a dataframe\ndf = pd.concat((pd.read_excel(f, skiprows=[0]) for f in all_files), ignore_index=True)\n\n'''\nfilter data based on gameweek if you want specific data\ndf = df[df['Gameweek'](spesific game week)].reset_index(drop=True)\nexample: df = df[df['Gameweek']&lt;18], if you want filter data based on first 18 gameweek\n'''\n\ndf\n</code></pre>"},{"location":"preparation/dataframe/#data-frame-from-timeline-report","title":"Data Frame from Timeline Report","text":"<pre><code>#mount to gdrive\nfrom google.colab import drive\ndrive.mount('/content/gdrive', force_remount=True)\n\n#loading all the files\npath = '/content/gdrive/MyDrive/Data/Liga Indonesia 2024/Liga 1/Timeline'\nall_files = glob.glob(os.path.join(path, \"*.xlsx\"))\n#load all the files to a dataframe\ndx = pd.DataFrame()\nfor f in all_files:\n  temp = pd.read_excel(f, skiprows=[0])\n  dx = pd.concat([dx, temp], ignore_index=True)\n\n'''\nfilter data based on gameweek if you want specific data\ndf = df[df['Gameweek'](spesific game week)].reset_index(drop=True)\nexample: df = df[df['Gameweek']&lt;18], if you want filter data based on first 18 gameweek\n'''\n\ndx\n</code></pre>"},{"location":"preparation/dataframe/#expected-goal-xg-data-frame","title":"Expected Goal (xG) Data Frame","text":"<pre><code>xg = pd.DataFrame()\nfor i in range(1,28):\n  path = '/content/gdrive/MyDrive/xG/GW '+str(i)\n  all_files = glob.glob(os.path.join(path, \"*.csv\"))\n  #load all the files to a dataframe\n  dy = pd.DataFrame()\n  for f in all_files:\n    temp = pd.read_csv(f)\n    dy = pd.concat([dy, temp], ignore_index=True)\n  xg = pd.concat([xg, dy], ignore_index=True)\nxg\n</code></pre>"},{"location":"preparation/dataframe/#player-data-base","title":"Player Data Base","text":"<pre><code>db = pd.read_excel('player.xlsx')\ndb\n</code></pre>"},{"location":"preparation/libprep/","title":"Preparation Install Code","text":"<p>Prepare some code to install</p>"},{"location":"preparation/libprep/#install-fundamental-python-library","title":"Install fundamental python library","text":"<pre><code>import os\nimport pandas as pd\nimport glob\nfrom datetime import date\nimport numpy as np\nfrom sklearn import preprocessing\n</code></pre>"},{"location":"preparation/libprep/#install-visualization-library","title":"Install visualization library","text":"<pre><code>import matplotlib.pyplot as plt\nfrom matplotlib.cm import ScalarMappable # creating scalar mappable objects for color mapping\nfrom matplotlib.lines import Line2D # creating custom lines\nimport matplotlib.patches as mpatches # customize graphical shapes and patches\nfrom matplotlib.patches import Patch\nimport matplotlib.font_manager as fm\nimport matplotlib.ticker as ticker\nfrom matplotlib import rcParams\nimport matplotlib.patheffects as path_effects\nfrom matplotlib.colors import ListedColormap, LinearSegmentedColormap\nfrom matplotlib.offsetbox import (OffsetImage, AnnotationBbox)\nimport seaborn as sns\n</code></pre>"},{"location":"preparation/libprep/#install-football-library-mplsoccer","title":"Install football library (mplsoccer)","text":"<pre><code>!pip install mplsoccer\nfrom mplsoccer import Pitch, VerticalPitch, PyPizza, Radar, grid\nfrom matplotlib.legend_handler import HandlerLine2D\nfrom matplotlib.patches import FancyArrowPatch\nfrom matplotlib.patches import FancyBboxPatch\nimport matplotlib.patches as patches\n\nfrom PIL import Image\nfrom tempfile import NamedTemporaryFile\nimport urllib\nimport os\n\nfrom textwrap import wrap # countries name lisibility\nfrom tempfile import NamedTemporaryFile\nimport urllib\n\ngithub_url = 'https://github.com/google/fonts/blob/main/ofl/poppins/Poppins-Bold.ttf'\nurl = github_url + '?raw=true'\n\nresponse = urllib.request.urlopen(url)\nf = NamedTemporaryFile(delete=False, suffix='.ttf')\nf.write(response.read())\nf.close()\n\nbold = fm.FontProperties(fname=f.name)\n\ngithub_url = 'https://github.com/google/fonts/blob/main/ofl/poppins/Poppins-Regular.ttf'\nurl = github_url + '?raw=true'\n\nresponse = urllib.request.urlopen(url)\nf = NamedTemporaryFile(delete=False, suffix='.ttf')\nf.write(response.read())\nf.close()\n\nreg = fm.FontProperties(fname=f.name)\n\ngithub_url = 'https://github.com/google/fonts/blob/main/ofl/poppins/Poppins-Italic.ttf'\nurl = github_url + '?raw=true'\n\nresponse = urllib.request.urlopen(url)\nf = NamedTemporaryFile(delete=False, suffix='.ttf')\nf.write(response.read())\nf.close()\n\nita = fm.FontProperties(fname=f.name)\n\npath_eff = [path_effects.Stroke(linewidth=2, foreground='#ffffff'),\n            path_effects.Normal()]\n</code></pre>"},{"location":"processing/matchmomentum/","title":"Match Momentum","text":"<p>Match momentum refers to the quantitatve representation that measures the swing of the match and which team is creating threatening situations at certain points in time. It also show important actions at certain time, example: goal, subs, and cards</p> <p>Steps for python code that used to build match momentum graphic from timeline excel report in each round.</p>"},{"location":"processing/matchmomentum/#creating-momentum-function","title":"Creating Momentum Function","text":"<pre><code>def genmomentum(data1, data2):\n  '''\n  Generating momentum based on passing and attacking thread\n\n  Parameters:\n    data1 (pd.DataFrame): First-half event data.\n    data2 (pd.DataFrame): Second-half event data.\n\n    Returns:\n    A matplotlib figure containing momentum plots for both halves\n  '''\n  # duplicate to prevent direct modifying\n  df1 = data1.copy()\n  df2 = data2.copy()\n\n  # label first and second half\n  df1['Babak'] = 'Satu'\n  df2['Babak'] = 'Dua'\n  df = pd.concat([df1, df2], ignore_index=True)\n\n  # extract match and team info\n  temp = df1.copy()\n  temp['Home'] = temp['Match'].str.split(' vs ').str[0]\n  temp['Away'] = temp['Match'].str.split(' vs ').str[1]\n  home = temp['Home'].unique().tolist()[0]\n  away = temp['Away'].unique().tolist()[0]\n  mtch = temp['Match'].unique().tolist()[0]\n\n  # extract passing and zones (active-passive zone)\n  '''\n  df_match = df.copy()\n  df_match = df_match[['Team','Action','Min','Babak','X1','Y1','X2','Y2']]\n  df_match = df_match[(df_match['Action']=='passing')]\n  '''\n  df_match = df.copy()\n  df_match = df_match[['Team','Action','Min','Babak','Act Zone','Pas Zone']]\n  df_match = df_match[(df_match['Action']=='passing')]\n\n  #Cleaning Data\n  shots = df_match.copy()\n  shots['Mins'] = shots['Min'].str.split(' : ').str[0]\n  shots['Mins'].fillna(shots['Min'], inplace=True)\n  shots['Mins'] = shots['Mins'].astype(float)\n</code></pre>"},{"location":"processing/matchmomentum/#calculating-expected-threads-xt","title":"Calculating expected threads (xT)","text":"<p>Continue from function above</p> <pre><code>  '''\n  Parameters:\n    ht = dataframe from first half\n    ft = dataframe from second half\n\n    Returns:\n    weighted xT momentum dataframe\n  '''\n  # split xT into first and second half\n  ht = shots[shots['Babak']=='Satu'].reset_index(drop=True)\n  ft = shots[shots['Babak']=='Dua'].reset_index(drop=True)\n\n  # create each round dataframes and their labels\n  data = [ht, ft]\n  babak = ['Satu', 'Dua']\n  momentum_df = pd.DataFrame()\n\n  # loop through each round\n  for fh, i in zip(data, babak):\n    # get the maximum xT value\n    max_xT_per_minute = fh.groupby(['Team', 'Mins'])['xT'].max().reset_index()\n    minutes = sorted(fh['Mins'].unique())\n\n    HOME_TEAM = home\n    AWAY_TEAM = away\n    # weighted xT values\n    weighted_xT_sum = {HOME_TEAM: [], AWAY_TEAM: []}\n    momentum = []\n\n    # parameters for the function\n    window_size = 4\n    decay_rate = 0.25\n\n    # calculate momentum for each minute\n    for current_minute in minutes:\n      for team in weighted_xT_sum.keys():\n        # get recent xT values\n        recent_xT_values = max_xT_per_minute[(max_xT_per_minute['Team'] == team) &amp;\n                                             (max_xT_per_minute['Mins'] &lt;= current_minute) &amp;\n                                             (max_xT_per_minute['Mins'] &gt; current_minute - window_size)]\n\n        # apply exponential decay weights\n        weights = np.exp(-decay_rate * (current_minute - recent_xT_values['Mins'].values))\n        # compute weighted sum of xT values\n        weighted_sum = np.sum(weights * recent_xT_values['xT'].values)\n        #store the result\n        weighted_xT_sum[team].append(weighted_sum)\n\n      momentum.append(weighted_xT_sum[HOME_TEAM][-1] - weighted_xT_sum[AWAY_TEAM][-1])\n\n    # create dataframe with momentum values for each round\n    fh = pd.DataFrame({'minute': minutes,'momentum': momentum})\n    fh['Babak'] = i\n    # append to the full momentum dataframe\n    momentum_df = pd.concat([momentum_df, fh], ignore_index=True)\n</code></pre>"},{"location":"processing/matchmomentum/#create-momentum-graphics","title":"Create Momentum Graphics","text":"<p>Finishing function, return to figure <pre><code>  # calling visualization code\n  from scipy.ndimage import gaussian_filter1d\n  fig, axs = plt.subplots(nrows=1, ncols=2, figsize=(20, 10), dpi=500)\n  fig.subplots_adjust(wspace=0.05)\n  fig.patch.set_facecolor('#FFFFFF')\n  axs = axs.flatten()\n\n  # plot minute pole (every 15 minutes)\n  m = [0, 15, 30, 45, 60, 75, 90]\n\n  # plot each round\n  for i in range(0,2):\n    axs[i].set_ylim(-0.3, 0.3)\n    axs[i].set_facecolor('#FFFFFF')\n    if i == 0:\n      auxdata = momentum_df[momentum_df['Babak']=='Satu'].reset_index(drop=True)\n      test = aksi[aksi['Babak']=='Satu'].reset_index(drop=True)\n      temp = test[test['Mins'].duplicated()==False].reset_index(drop=True)\n      d1 = test[test['Mins'].duplicated()==True].reset_index(drop=True)\n      d2 = d1[d1['Mins'].duplicated()==True].reset_index(drop=True)\n      d3 = d2[d2['Mins'].duplicated()==True].reset_index(drop=True)\n      d4 = d3[d3['Mins'].duplicated()==True].reset_index(drop=True)\n      rlim = auxdata['minute'].max()\n      axs[i].set_xticks(m[:4])\n      axs[i].set_xlim(0, rlim)\n\n      DC_to_FC = axs[0].transData.transform\n      FC_to_NFC = fig.transFigure.inverted().transform\n      DC_to_NFC = lambda x: FC_to_NFC(DC_to_FC(x))\n\n      kons = 7.9\n    else:\n      auxdata = momentum_df[momentum_df['Babak']=='Dua'].reset_index(drop=True)\n      test = aksi[aksi['Babak']=='Dua'].reset_index(drop=True)\n      temp = test[test['Mins'].duplicated()==False].reset_index(drop=True)\n      d1 = test[test['Mins'].duplicated()==True].reset_index(drop=True)\n      d2 = d1[d1['Mins'].duplicated()==True].reset_index(drop=True)\n      d3 = d2[d2['Mins'].duplicated()==True].reset_index(drop=True)\n      d4 = d3[d3['Mins'].duplicated()==True].reset_index(drop=True)\n      rlim = auxdata['minute'].max()\n      axs[i].set_xticks(m[-4:])\n      axs[i].set_xlim(45, rlim)\n\n      DC_to_FC = axs[1].transData.transform\n      FC_to_NFC = fig.transFigure.inverted().transform\n      DC_to_NFC = lambda x: FC_to_NFC(DC_to_FC(x))\n\n      kons = 8.1\n\n    # create momentum curve\n    auxdata['momentum_smooth'] = gaussian_filter1d(auxdata['momentum'], sigma=1)\n    for j in range(len(auxdata)):\n      if auxdata['momentum_smooth'][j] &gt; 0:\n        axs[i].plot(auxdata['minute'][j], auxdata['momentum_smooth'][j], color='#15AF15')\n      else:\n        axs[i].plot(auxdata['minute'][j], auxdata['momentum_smooth'][j], color='#AF15AF')\n\n    # fill under momentum curve\n    axs[i].fill_between(auxdata['minute'], auxdata['momentum_smooth'], where=(auxdata['momentum_smooth'] &gt; 0),\n                        color='#15AF15', alpha=0.5, interpolate=True)\n    axs[i].fill_between(auxdata['minute'], auxdata['momentum_smooth'], where=(auxdata['momentum_smooth'] &lt; 0),\n                        color='#AF15AF', alpha=0.5, interpolate=True)\n    axs[i].axhline(0, color='#000000', linewidth=.5)\n\n    # load and plot for important events (goals, cards, subs)\n    dupe = [temp, d1, d2, d3, d4]\n    nilai_yh = [0.23-0.035*i for i in range(5)]\n    nilai_ya = [-0.32+0.035*i for i in range(5)]\n    for x, zh, za in zip(dupe, nilai_yh, nilai_ya):\n      for j in range(len(x)):\n        if x['Team'][j] == home:\n          ymax = 0.945\n          y1 = zh\n          suf = '-H.png'\n        else:\n          ymax = 0.055\n          y1 = za\n          suf = '-A.png'\n\n        if x['Action'][j] == 'goal':\n          icon = '/content/gdrive/MyDrive/Data/Liga Indonesia 2024/Database/Icon/Goal'+suf\n          axs[i].axvline(x['Mins'][j], color='#000000', lw=1, ymin=0.5, ymax=ymax, zorder=3, ls='--')\n        elif x['Action'][j] == 'yellow card':\n          icon = '/content/gdrive/MyDrive/Data/Liga Indonesia 2024/Database/Icon/YC'+suf\n        elif x['Action'][j] == 'red card':\n          icon = '/content/gdrive/MyDrive/Data/Liga Indonesia 2024/Database/Icon/RC'+suf\n        elif x['Action'][j] == '2yellow':\n          icon = '/content/gdrive/MyDrive/Data/Liga Indonesia 2024/Database/Icon/2Y'+suf\n        elif x['Action'][j] == 'subs':\n          icon = '/content/gdrive/MyDrive/Data/Liga Indonesia 2024/Database/Icon/Subs'+suf\n        elif x['Action'][j] == 'own goal':\n          icon = '/content/gdrive/MyDrive/Data/Liga Indonesia 2024/Database/Icon/OG'+suf\n        elif x['Action'][j] == 'penalty goal':\n          icon = '/content/gdrive/MyDrive/Data/Liga Indonesia 2024/Database/Icon/P'+suf\n        else:\n          icon = '/content/gdrive/MyDrive/Data/Liga Indonesia 2024/Database/Icon/PM'+suf\n        ax_coords = DC_to_NFC([x['Mins'][j]-kons, y1])\n        logo_ax = fig.add_axes([ax_coords[0], ax_coords[1], 0.125, 0.125], anchor = \"C\")\n        club_icon = Image.open(icon)\n        logo_ax.imshow(club_icon)\n        logo_ax.axis('off')\n\n    for k in m:\n      axs[i].axvline(k, color='#000000', lw=2, ymin=-0.3, ymax=3, zorder=-2, ls='--', alpha=0.075)\n\n    axs[i].spines['top'].set_visible(False)\n    axs[i].spines['right'].set_visible(False)\n    axs[i].spines['bottom'].set_visible(False)\n    axs[i].spines['left'].set_visible(False)\n    axs[i].set_yticks([])\n    axs[i].xaxis.set_ticks_position('none')\n    axs[i].tick_params(axis='x', colors='#000000')\n\n    for tick in axs[i].get_xticklabels():\n      tick.set_fontproperties(reg)\n    axs[i].xaxis.set_tick_params(labelsize=15)\n\n  # set title in each round\n  axs[0].set_title('FIRST HALF', fontproperties=bold, size=20, alpha=0.35)\n  axs[1].set_title('SECOND HALF', fontproperties=bold, size=20, alpha=0.35)\n  #fig.suptitle('MATCH MOMENTUM', fontproperties=bold, size=30)\n\n  # set name for x-label (minute) and y-label (attacking threat)\n  fig.text(0.5, 0.025, 'Minute', ha='center', fontsize=18, fontproperties=bold)\n  fig.text(0.1, 0.5, 'Attacking Threat', va='center', ha='center', fontsize=18, fontproperties=bold, rotation=90)\n\n  # set title for match momentum\n  fig_text(0.1, 1, '&lt;'+home+'&gt; vs &lt;'+away+'&gt;', fontproperties=bold, size=32,\n           highlight_textprops=[{'color':'#15AF15'}, {'color':'#AF15AF'}], color='#000000')\n  fig.text(0.1, 0.93, 'Match Momentum | Liga 1 2024/25', fontsize=22, fontproperties=reg)\n  fig.savefig('Match Momentum - '+mtch+'.jpg', dpi=500, bbox_inches='tight', facecolor=fig.get_facecolor(), edgecolor='none')\n\n  return fig\n</code></pre></p> <p>Calling match momentum after create function <pre><code>#excel file and path are adjust based on yours\ndf1 = pd.read_excel('tl1.xlsx', skiprows=[0])\ndf2 = pd.read_excel('tl2.xlsx', skiprows=[0])\n\ngenmomentum(df1, df2)\n</code></pre></p>"},{"location":"processing/pradar/","title":"Player Radar Processing","text":"<p>Player radar is a visual representation of a player's performance across visual statistical categories, otfen display as a polygon or spider chart. In Lapangbola's player radar, we compare a player stats with league player average statistics on the same season based on some stat metrics.</p> <p>This page provides to creating player radar based from player excel report.</p> <p>All data frame should be called before creating action. How to create data frame can go to Data Frame page.</p>"},{"location":"processing/pradar/#create-action-list","title":"Create action list","text":"<p>first list: for all position (exclude goalkeeper)</p> <p>second list: for goalkeeper only <pre><code>metrik = ['Name','Team','MoP','Non-penalty goals','Non-penalty xG','NPxG/Shot','Shots','Shot on target ratio','Conversion ratio','Chances created','Assists',\n          'Passes-to-box','Through passes','Passes to final 3rd','Progressive passes','Long passes','Pass accuracy','Successful crosses',\n          'Successful dribbles','Offensive duel won ratio','Tackles','Intercepts','Recoveries','Blocks','Clearances','Aerial duel won ratio',\n          'Defensive duel won ratio','Passes','Passes received','Clean sheets','Shots on target faced','xGOT against','Goals conceded','Goals prevented',\n          'Save ratio','Sweepers','Crosses claimed']\n\njamet = ['Name','Team','MoP','Non-penalty goals','Shots','Chances created','Assists','Through passes','Progressive passes',\n         'Long passes','Successful crosses','Successful dribbles','Tackles','Intercepts','Recoveries','Blocks','Clearances',\n         'Total Pass','Aerial Duels','Offensive Duel','Offensive Duel - Won','Defensive Duel','Defensive Duel - Won','Goal',\n         'Shot on','Pass','Aerial Won','Penalty','Passes','Clean sheets','Sweepers','Crosses claimed']\n</code></pre></p>"},{"location":"processing/pradar/#calculate-per-90","title":"Calculate per 90","text":""},{"location":"processing/pradar/#create-per-90-function","title":"Create per 90 function","text":"<pre><code>#creating function\ndef get_sum90(report, tl, xg, db, gk, min):\n  #duplicate data for preventing direct modification\n  df = report.copy()\n  df2 = tl.copy()\n  db = db.copy()\n  gk = gk.copy()\n\n  dxg = xg.copy() #duplicate xg data\n  dxg = dxg[['Name','xG']]\n  dxg = dxg.groupby(['Name'], as_index=False).sum() #sum total xg, based on name player\n#redef action data name\n  df['Non-penalty goals'] = df['Goal']\n  df['Shots'] = df['Shot on']+df['Shot off']+df['Shot Blocked']\n  df['Chances created'] = df['Create Chance']\n  df['Assists'] = df['Assist']\n  df['Through passes'] = df['Pass - Through Pass']\n  df['Progressive passes'] = df['Pass - Progressive Pass']\n  df['Long passes'] = df['Pass - Long Ball']\n  df['Successful crosses'] = df['Cross']\n  df['Successful dribbles'] = df['Dribble']\n  df['Tackles'] = df['Tackle']\n  df['Intercepts'] = df['Intercept']\n  df['Recoveries'] = df['Recovery']\n  df['Blocks'] = df['Block']+df['Block Cross']\n  df['Clearances'] = df['Clearance']\n  df['Passes'] = df['Pass']\n  df['Clean sheets'] = df['Cleansheet']\n  df['Sweepers'] = df['Keeper - Sweeper']\n  df['Crosses claimed'] = df['Cross Claim']\n#redef and sum data name\n  df['Total Pass'] = df['Pass']+df['Pass Fail'] #total passing\n  df['Aerial Duels'] = df['Aerial Won']+df['Aerial Lost'] #total aerial\n  df['Offensive Duel - Won'] = df['Offensive Duel - Won']+df['Fouled']+df['Dribble'] #total off duel won\n  df['Offensive Duel - Lost'] = df['Offensive Duel - Lost']+df['Loose Ball - Tackle']+df['Dribble Fail'] #total off duel lost\n  df['Defensive Duel - Won'] = df['Defensive Duel - Won']+df['Tackle'] #total def duel won\n  df['Defensive Duel - Lost'] = df['Defensive Duel - Lost']+df['Foul']+df['Dribbled Past'] #total def duel lost\n  df['Offensive Duel'] = df['Offensive Duel - Won']+df['Offensive Duel - Lost'] #total off duel\n  df['Defensive Duel'] = df['Defensive Duel - Won']+df['Defensive Duel - Lost'] #total def duel\n  df['Penalty'] = df['Penalty Goal']-df['Penalty Missed'] #total pen shot\n#merging action dataframe\n  df_data = df[jamet]\n  df_sum = df_data.groupby(['Name','Team'], as_index=False).sum() #aggregating stat based on player and team\n  df_sum = pd.merge(df_sum, dxg, on='Name', how='outer') #merging with xG data\n#calculate ratio stat (rounding two digits)\n  df_sum['Non-penalty xG'] = round(df_sum['xG']-(df_sum['Penalty']*0.593469436750998),2) #non penalty xG\n  df_sum['NPxG/Shot'] = round(df_sum['Non-penalty xG']/(df_sum['Shots']-df_sum['Penalty']),2) #ratio non penalty xg / shot\n  df_sum['Conversion ratio'] = round(df_sum['Goal']/df_sum['Shots'],2) #calculate convertion ratio goal\n  df_sum['Shot on target ratio'] = round(df_sum['Shot on']/df_sum['Shots'],2) #calculate shot on ratio\n  df_sum['Pass accuracy'] = round(df_sum['Pass']/df_sum['Total Pass'],2) #calculate pass accuracy\n  df_sum['Aerial duel won ratio'] = round(df_sum['Aerial Won']/df_sum['Aerial Duels'],2) #calculate aerial duel\n  df_sum['Offensive duel won ratio'] = round(df_sum['Offensive Duel - Won']/df_sum['Offensive Duel'],2) #calculate off duel won\n  df_sum['Defensive duel won ratio'] = round(df_sum['Defensive Duel - Won']/df_sum['Defensive Duel'],2) #calculate def duel lost\n#merging data\n  #merging with pass to box data\n  temp = proses_tl(df2)\n  df_sum = pd.merge(df_sum, temp, on='Name', how='outer')\n  #merging with received pass data\n  temp2 = proses_tl2(df2)\n  df_sum = pd.merge(df_sum, temp2, on='Name', how='outer')\n\n  gk = gk[['Name','Save','Penalty Save','Total Shots','Goals Conceded',\n           'xGOTA','Goals Prevented']] #def gk column\n  gk['Save ratio'] = round((gk['Save']+gk['Penalty Save'])/gk['Total Shots'],2) #calculate save ratio\n  gk['Shots on target faced'] = gk['Total Shots'] #def shot on faced\n  gk['xGOT against'] = gk['xGOTA'] #def xGOT\n  gk['Goals conceded'] = gk['Goals Conceded'] #rename goals conceded\n  gk['Goals prevented'] = gk['Goals Prevented'] #rename goals prevented\n  gk = gk[['Name','Save ratio','Shots on target faced','xGOT against','Goals conceded','Goals prevented']] #redef gk column\n#merging new gk data\n  df_sum = pd.merge(df_sum, gk, on='Name', how='outer')\n#cleaning missing data\n  df_sum.replace([np.inf, -np.inf], 0, inplace=True) #replacing infinity value with 0\n  df_sum.fillna(0, inplace=True)\n\n  temp = df_sum.drop(['Name','Team'], axis=1) #removing name and team column\n#calculate per 90 data\n  def p90_Calculator(variable_value):\n    p90_value = round((((variable_value/temp['MoP']))*90),2)\n    return p90_value\n  p90 = temp.apply(p90_Calculator)\n#creating per 90 column from data frame\n  p90['Name'] = df_sum['Name']\n  p90['Team'] = df_sum['Team']\n  p90['MoP'] = df_sum['MoP']\n  p90['NPxG/Shot'] = df_sum['NPxG/Shot']\n  p90['Conversion ratio'] = df_sum['Conversion ratio']\n  p90['Shot on target tatio'] = df_sum['Shot on target ratio']\n  p90['Pass accuracy'] = df_sum['Pass accuracy']\n  p90['Aerial duel won ratio'] = df_sum['Aerial duel won ratio']\n  p90['Offensive duel won ratio'] = df_sum['Offensive duel won ratio']\n  p90['Defensive duel won ratio'] = df_sum['Defensive duel won ratio']\n  p90['Save ratio'] = df_sum['Save ratio']\n\n  p90 = p90[metrik] #getting column from 'metrik' variable\n  p90['Name'] = p90['Name'].str.strip() #removing unnecessary space at begining/end in the name column (ex: spaces, tabs, newlines)\n#merge adv data and position\n  pos = db[['Name','Position']] #def name and position column\n  data_full = pd.merge(p90, pos, on='Name', how='left')\n  data_full = data_full.loc[(data_full['MoP']&gt;=min)].reset_index(drop=True) #showing player who have minimum minute of play\n\n  return data_full, df_sum\n</code></pre>"},{"location":"processing/pradar/#show-per-90-data-frame","title":"Show per 90 data frame","text":"<pre><code>mins = 360 #set minimum minutes play before analyze\nrank_p90 = get_sum90(df, dx, xg, db, gk, mins)[0] #get per 90 data from get_sum90 function (index = 0)\nrank_tot = get_sum90(df, dx, xg, db, gk, mins)[1] #get total stats from get_sum90 function (index = 1)\nrank_p90 #show data frame\n</code></pre>"},{"location":"processing/pradar/#group-player-data-based-on-position","title":"Group player data based on position","text":"<pre><code>def get_pct(data):\n  data_full = data.copy() #duplicate data for preventing direct modification\n  df4 = data_full.groupby('Position', as_index=False) #group data and execute functions on these groups\n  #separating data based on 'position' value\n  midfielder = df4.get_group('Midfielder')\n  goalkeeper = df4.get_group('Goalkeeper')\n  forward = df4.get_group('Forward')\n  att_10 = df4.get_group('Attacking 10')\n  center_back = df4.get_group('Center Back')\n  fullback = df4.get_group('Fullback')\n  winger = df4.get_group('Winger')\n\n  #calculating the average stats per position\n  '''\n  1. duplicate data based on grouping position\n  2. drop 'name', 'position', 'team' column for temporary\n  3. calculate mean value for every row\n  4. add again 'name', 'position', 'team' column\n  5. replace NaN value with 'League Average'\n  '''\n\n  #winger\n  temp = winger.copy()\n  winger = winger.drop(['Name','Position','Team'], axis=1)\n  winger.loc['mean'] = round((winger.mean()),2)\n  winger['Name'] = temp['Name']\n  winger['Position'] = temp['Position']\n  winger['Team'] = temp['Team']\n  values1 = {\"Name\": 'Average W', \"Position\": 'Winger', \"Team\": 'League Average'}\n  winger = winger.fillna(value=values1)\n\n  #fb\n  temp = fullback.copy()\n  fullback = fullback.drop(['Name','Position','Team'], axis=1)\n  fullback.loc['mean'] = round((fullback.mean()),2)\n  fullback['Name'] = temp['Name']\n  fullback['Position'] = temp['Position']\n  fullback['Team'] = temp['Team']\n  values2 = {\"Name\": 'Average FB', \"Position\": 'Fullback', \"Team\": 'League Average'}\n  fullback = fullback.fillna(value=values2)\n\n  #cb\n  temp = center_back.copy()\n  center_back = center_back.drop(['Name','Position','Team'], axis=1)\n  center_back.loc['mean'] = round((center_back.mean()),2)\n  center_back['Name'] = temp['Name']\n  center_back['Position'] = temp['Position']\n  center_back['Team'] = temp['Team']\n  values3 = {\"Name\": 'Average CB', \"Position\": 'Center Back', \"Team\": 'League Average'}\n  center_back = center_back.fillna(value=values3)\n\n  #cam\n  temp = att_10.copy()\n  att_10 = att_10.drop(['Name','Position','Team'], axis=1)\n  att_10.loc['mean'] = round((att_10.mean()),2)\n  att_10['Name'] = temp['Name']\n  att_10['Position'] = temp['Position']\n  att_10['Team'] = temp['Team']\n  values4 = {\"Name\": 'Average CAM', \"Position\": 'Attacking 10', \"Team\": 'League Average'}\n  att_10 = att_10.fillna(value=values4)\n\n  #forward\n  temp = forward.copy()\n  forward = forward.drop(['Name','Position','Team'], axis=1)\n  forward.loc['mean'] = round((forward.mean()),2)\n  forward['Name'] = temp['Name']\n  forward['Position'] = temp['Position']\n  forward['Team'] = temp['Team']\n  values5 = {\"Name\": 'Average FW', \"Position\": 'Forward', \"Team\": 'League Average'}\n  forward = forward.fillna(value=values5)\n\n  #gk\n  temp = goalkeeper.copy()\n  goalkeeper = goalkeeper.drop(['Name','Position','Team',], axis=1)\n  goalkeeper.loc['mean'] = round((goalkeeper.mean()),2)\n  goalkeeper['Name'] = temp['Name']\n  goalkeeper['Position'] = temp['Position']\n  goalkeeper['Team'] = temp['Team']\n  values6 = {\"Name\": 'Average GK', \"Position\": 'Goalkeeper', \"Team\": 'League Average'}\n  goalkeeper = goalkeeper.fillna(value=values6)\n\n  #cm\n  temp = midfielder.copy()\n  midfielder = midfielder.drop(['Name','Position','Team'], axis=1)\n  midfielder.loc['mean'] = round((midfielder.mean()),2)\n  midfielder['Name'] = temp['Name']\n  midfielder['Position'] = temp['Position']\n  midfielder['Team'] = temp['Team']\n  values7 = {\"Name\": 'Average CM', \"Position\": 'Midfielder', \"Team\": 'League Average'}\n  midfielder = midfielder.fillna(value=values7)\n\n  #percentile rank for all position, times by 100 and round with 0, convert to integer\n  rank_cm = round(((midfielder.rank(pct=True))*100),0).astype(int)\n  rank_gk = round(((goalkeeper.rank(pct=True))*100),0).astype(int)\n  rank_fw = round(((forward.rank(pct=True))*100),0).astype(int)\n  rank_cam = round(((att_10.rank(pct=True))*100),0).astype(int)\n  rank_cb = round(((center_back.rank(pct=True))*100),0).astype(int)\n  rank_fb = round(((fullback.rank(pct=True))*100),0).astype(int)\n  rank_w = round(((winger.rank(pct=True))*100),0).astype(int)\n\n  #add back Name and Position column\n  rank_cm['Name'] = midfielder['Name']\n  rank_gk['Name'] = goalkeeper['Name']\n  rank_fw['Name'] = forward['Name']\n  rank_cam['Name'] = att_10['Name']\n  rank_cb['Name'] = center_back['Name']\n  rank_fb['Name'] = fullback['Name']\n  rank_w['Name'] = winger['Name']\n\n  rank_cm['Position'] = midfielder['Position']\n  rank_gk['Position'] = goalkeeper['Position']\n  rank_fw['Position'] = forward['Position']\n  rank_cam['Position'] = att_10['Position']\n  rank_cb['Position'] = center_back['Position']\n  rank_fb['Position'] = fullback['Position']\n  rank_w['Position'] = winger['Position']\n\n  rank_cm['Team'] = midfielder['Team']\n  rank_gk['Team'] = goalkeeper['Team']\n  rank_fw['Team'] = forward['Team']\n  rank_cam['Team'] = att_10['Team']\n  rank_cb['Team'] = center_back['Team']\n  rank_fb['Team'] = fullback['Team']\n  rank_w['Team'] = winger['Team']\n\n  rank_cm['MoP'] = midfielder['MoP']\n  rank_gk['MoP'] = goalkeeper['MoP']\n  rank_fw['MoP'] = forward['MoP']\n  rank_cam['MoP'] = att_10['MoP']\n  rank_cb['MoP'] = center_back['MoP']\n  rank_fb['MoP'] = fullback['MoP']\n  rank_w['MoP'] = winger['MoP']\n\n  #merge all rank position into one data frame\n  rank_liga = pd.concat([rank_cm, rank_gk, rank_fw, rank_cam, rank_cb, rank_fb, rank_w]).reset_index(drop=True)\n  rank_liga['MoP'] = rank_liga['MoP'].astype(int) #change 'MoP' value into integer\n\n  return rank_liga #return dataframe that contain percentile based on their positions\n\n  #output: dataframe contains stat ranks (in percentile) per player\n\nabc = get_pct(tengs) #process percentile function above\n</code></pre> <p>Merge with database player data frame <pre><code>tk = db[['Name','Nationality']] #create new dataframe from db (database player) dataframe\nabc = pd.merge(abc, tk, on='Name', how='left') #merge dataframe based on 'Name' column, ensure abc's row maintained\nabc = abc[abc['Nationality']=='Indonesia'].reset_index(drop=True) #filter data only contain 'Indonesia' value in 'Nationality' column\nabc\n</code></pre></p> <p>Create dictionary action metrics based on player's position <pre><code>posdict = {'gk':{'position':'Goalkeeper',\n                 'metrics':['Name','Passes','Pass accuracy','Long passes','Progressive passes','Passes received','Clean sheets','Shots on target faced',\n                            'xGOT against','Goals conceded','Goals prevented','Save ratio','Sweepers','Crosses claimed','Intercepts']},\n           'cb':{'position':'Center Back',\n                 'metrics':['Name','Non-penalty goals','Shots',\n                            'Passes to final 3rd','Progressive passes','Long passes','Pass accuracy',\n                            'Tackles','Intercepts','Recoveries','Blocks','Clearances','Aerial duel won ratio','Defensive duel won ratio']},\n           'fb':{'position':'Fullback',\n                 'metrics':['Name','Non-penalty goals','Non-penalty xG','Shots','Chances created','Assists',\n                            'Passes-to-box','Through passes','Passes to final 3rd','Progressive passes','Pass accuracy','Successful dribbles','Successful crosses','Offensive duel won ratio',\n                            'Tackles','Intercepts','Recoveries','Blocks','Clearances','Aerial duel won ratio','Defensive duel won ratio']},\n           'cm':{'position':'Midfielder',\n                 'metrics':['Name','Non-penalty goals','Non-penalty xG','NPxG/Shot','Shots','Shot on target ratio','Chances created','Assists',\n                            'Passes-to-box','Through passes','Passes to final 3rd','Progressive passes','Long passes','Pass accuracy','Successful dribbles','Offensive duel won ratio',\n                            'Tackles','Intercepts','Recoveries','Clearances','Defensive duel won ratio']},\n           'cam/w':{'position':'Attacking 10/Winger',\n                    'metrics':['Name','Non-penalty goals','Non-penalty xG','NPxG/Shot','Shots','Shot on target ratio','Conversion ratio','Chances created','Assists',\n                               'Passes-to-box','Through passes','Passes to final 3rd','Progressive passes','Pass accuracy','Successful dribbles','Offensive duel won ratio',\n                               'Tackles','Intercepts','Recoveries','Defensive duel won ratio']},\n           'fw':{'position':'Forward',\n                 'metrics':['Name','Non-penalty goals','Non-penalty xG','NPxG/Shot','Shots','Shot on target ratio','Conversion ratio','Chances created','Assists',\n                            'Passes-to-box','Through passes','Progressive passes','Pass accuracy','Successful dribbles','Offensive duel won ratio',\n                            'Tackles','Intercepts','Recoveries','Aerial duel won ratio','Defensive duel won ratio']}}\n</code></pre></p>"},{"location":"processing/pradar/#player-radar-visualization","title":"Player Radar Visualization","text":"<pre><code>def player_radar(komp, pos, klub, name, data, mins):\n  df = data.copy() #duplicate data for preventing direct modification\n  df = df[df['Position']==pos] #filter data based on player position\n\n  #DATA\n  '''\n  if/elif ('getting spec position: forward, mid, defender, gk')\n    temp = df[posdict[\"player position\"]['metrics']].reset_index(drop=True)\n    temp = temp[(temp['Name']==name) | (temp['Name']=='Average pos')].reset_index(drop=True) ---&gt; get spesific name\n\n    slice_colors = ['#e900ff']*offense act + ['#faeb2c']*defence act + ['#74ee15']*possesion act ----&gt;slice color can be adjusted\n  '''\n  if (pos=='Forward'):\n    temp = df[posdict['fw']['metrics']].reset_index(drop=True)\n    temp = temp[(temp['Name']==name) | (temp['Name']=='Average FW')].reset_index(drop=True)\n\n    slice_colors = ['#e900ff']*8 + ['#faeb2c']*6 + ['#74ee15']*5\n\n  elif (pos=='Winger') or (pos=='Attacking 10'):\n    temp = df[posdict['cam/w']['metrics']].reset_index(drop=True)\n    if (pos=='Winger'):\n      temp = temp[(temp['Name']==name) | (temp['Name']=='Average W')].reset_index(drop=True)\n    else:\n      temp = temp[(temp['Name']==name) | (temp['Name']=='Average CAM')].reset_index(drop=True)\n\n    slice_colors = ['#e900ff']*8 + ['#faeb2c']*7 + ['#74ee15']*4\n\n  elif (pos=='Midfielder'):\n    temp = df[posdict['cm']['metrics']].reset_index(drop=True)\n    temp = temp[(temp['Name']==name) | (temp['Name']=='Average CM')].reset_index(drop=True)\n\n    slice_colors = ['#e900ff']*7 + ['#faeb2c']*8 + ['#74ee15']*5\n\n  elif (pos=='Fullback'):\n    temp = df[posdict['fb']['metrics']].reset_index(drop=True)\n    temp = temp[(temp['Name']==name) | (temp['Name']=='Average FB')].reset_index(drop=True)\n\n    slice_colors = ['#e900ff']*5 + ['#faeb2c']*8 + ['#74ee15']*7\n\n  elif (pos=='Center Back'):\n    temp = df[posdict['cb']['metrics']].reset_index(drop=True)\n    temp = temp[(temp['Name']==name) | (temp['Name']=='Average CB')].reset_index(drop=True)\n\n    slice_colors = ['#e900ff']*2 + ['#faeb2c']*4 + ['#74ee15']*7\n\n  elif (pos=='Goalkeeper'):\n    temp = df[posdict['gk']['metrics']].reset_index(drop=True)\n    temp = temp[(temp['Name']==name) | (temp['Name']=='Average GK')].reset_index(drop=True)\n\n    slice_colors = ['#e900ff']*5 + ['#faeb2c']*6 + ['#74ee15']*3\n\n  #temp = temp.drop(['Team'], axis=1)\n\n  #extract 'Average' data as comparasion\n  avg_player = temp[temp['Name'].str.contains('Average')] #extract 'Average' data from 'Nama' column\n  av_name = list(avg_player['Name'])[0] #extract 'Average' data as first index\n  params = list(temp.columns) #create columns list based on function dataframe\n  params = params[1:] #only processing after index 1 (column 'Name' = index 0)\n\n  a_values = []\n  b_values = []\n\n  for x in range(len(temp['Name'])):\n    if temp['Name'][x] == name:\n      a_values = temp.iloc[x].values.tolist()\n    if temp['Name'][x] == av_name:\n      b_values = temp.iloc[x].values.tolist()\n\n  a_values = a_values[1:]\n  b_values = b_values[1:]\n\n  values = [a_values,b_values]\n  maxmin = pd.DataFrame({'param':params,'value':a_values,'average':b_values})\n  for index, value in enumerate(params):\n    if value == 'Progressive passes':\n      params[index] = 'Progressive\\npasses'\n    elif value == 'long passes':\n      params[index] = 'Long\\npasses'\n    elif value == 'Pass accuracy':\n      params[index] = 'Pass\\naccuracy'\n    elif value == 'Successful crosses':\n      params[index] = 'Successful\\ncrosses'\n    elif value == 'Successful dribbles':\n      params[index] = 'Successful\\ndribbles'\n    elif value == 'Offensive duel won ratio':\n      params[index] = 'Offensive duel\\nwon ratio'\n    elif value == 'Defensive duel won ratio':\n      params[index] = 'Defensive duel\\nwon ratio'\n    elif value == 'Aerial duel won ratio':\n      params[index] = 'Aerial\\nduel won\\nratio'\n    elif value == 'Passes to final 3rd':\n      params[index] = 'Passes to\\nfinal 3rd'\n    elif value == 'Through passes':\n      params[index] = 'Through\\npasses'\n    elif value == 'Non-penalty goals':\n      params[index] = 'Non-penalty\\ngoals'\n    elif value == 'Shot on target ratio':\n      params[index] = 'Shot on\\ntarget ratio'\n    elif value == 'Conversion ratio':\n      params[index] = 'Conversion\\nratio'\n    elif value == 'Chances created':\n      params[index] = 'Chances\\ncreated'\n    elif value == 'Shots on target faced':\n      params[index] = 'Shots on\\ntarget faced'\n    elif value == 'Goals prevented':\n      params[index] = 'Goals\\nprevented'\n    elif value == 'Goals conceded':\n      params[index] = 'Goals\\nconceded'\n\n  #PLOT\n  # set figure size\n  fig = plt.figure(figsize=(10,10))\n\n  # plot polar axis\n  ax = plt.subplot(111, polar=True)\n  ax.set_theta_direction(-1)\n  ax.set_theta_zero_location('N')\n\n  # Set the grid and spine off\n  fig.patch.set_facecolor('#FFFFFF')\n  ax.set_facecolor('#FFFFFF')\n  ax.spines['polar'].set_visible(False)\n  plt.axis('off')\n\n  # Add line in 20, 40, 60, 80\n  x2 = np.linspace(0, 2*np.pi, 50)\n  annot_x = [20 + x*20 for x in range(0,4)]\n  for z in annot_x:\n    ax.plot(x2, [z]*50, color='#000000', lw=1, ls='--', alpha=0.15, zorder=4)\n  ax.plot(x2, [100]*50, color='#000000', lw=2, zorder=10, alpha=0.5, ls=(0, (5, 1)))\n  # Set the coordinates limits\n  upperLimit = 100\n  lowerLimit = 0\n\n  # Compute max and min in the dataset\n  max = maxmin['value'].max()\n\n  # Let's compute heights: they are a conversion of each item value in those new coordinates\n  # In our example, 0 in the dataset will be converted to the lowerLimit (10)\n  # The maximum will be converted to the upperLimit (100)\n  slope = (max-lowerLimit)/max\n  heights = slope*maxmin['value'] + lowerLimit\n  avg_heights = slope*maxmin['average'] + lowerLimit\n  va_heights = maxmin['value']*0 + 90\n  #shadow = df.Value*0 + 100\n\n  # Compute the width of each bar. In total we have 2*Pi = 360\u00b0\n  width = 2*np.pi/len(a_values)\n\n  # Compute the angle each bar is centered on:\n  indexes = list(range(1, len(a_values)+1))\n  angles = [element*width for element in indexes]\n\n  # Draw bars\n  bars = ax.bar(x=angles, height=heights, width=width, bottom=lowerLimit, linewidth=2, edgecolor='#FFFFFF', zorder=3, alpha=1, color=slice_colors)\n  #bars = ax.bar(x=angles, height=shadow, width=width, bottom=lowerLimit, linewidth=2, edgecolor='#000000', zorder=2, alpha=0.15, color=slice_colors)\n\n  # Draw scatter plots for the averages and values\n  scas_av = ax.scatter(x=angles, y=avg_heights, s=150, c=slice_colors, zorder=5, ec='#000000')\n  #scas_va = ax.scatter(x=angles, y=va_heights, s=350, c='#000000',\n  #                     zorder=4, marker='s', lw=0.5, ec='#ffffff')\n\n  # Draw vertical lines for reference\n  ax.vlines(angles, 0, 100, color='#000000', ls='--', zorder=4, alpha=0.35)\n\n  # Add labels\n  for bar, angle, height, label, value in zip(bars,angles, heights, params, a_values):\n    # Labels are rotated. Rotation must be specified in degrees :(\n    rotation = np.rad2deg((np.pi/2)-angle)\n    # Flip some labels upside down\n    if (angle &lt;= np.pi/2) or (angle &gt;= (np.pi/2)+np.pi):\n        rotation = rotation+270\n    else:\n        rotation = rotation+90\n\n    # Finally add the labels and values\n    ax.text(x=angle, y=110, s=label, color='#000000', ha='center',\n            va='center', rotation=rotation, rotation_mode='anchor',\n            fontproperties=reg)\n    ax.text(x=angle, y=90, s=value, color='#000000', zorder=11, va='center',\n            ha='center', fontproperties=bold, bbox=dict(facecolor='#FFFFFF', edgecolor='#000000',\n                                                        boxstyle='circle, pad=0.5'))\n  if pos=='Goalkeeper':\n    fig.text(0.325, 0.9325, \"Distribution                                GK Metric                            Defending\",\n             fontproperties=reg, size=10, color='#000000', va='center')\n  else:\n    fig.text(0.325, 0.9325, \"Attacking                                Possession                            Defending\",\n             fontproperties=reg, size=10, color='#000000', va='center')\n\n  fig.patches.extend([plt.Circle((0.305, 0.935), 0.01, fill=True, color='#e900ff',\n                                    transform=fig.transFigure, figure=fig),\n                      plt.Circle((0.490, 0.935), 0.01, fill=True, color='#faeb2c',\n                                    transform=fig.transFigure, figure=fig),\n                      plt.Circle((0.668, 0.935), 0.01, fill=True, color='#74ee15',\n                                    transform=fig.transFigure, figure=fig),\n                      plt.Circle((0.15, 0.0425), 0.01, fill=True, color='#000000',\n                                 transform=fig.transFigure, figure=fig)])\n\n  fig.text(0.515, 0.985,name + ' - ' + klub, fontproperties=bold, size=18,\n           ha='center', color='#000000')\n  fig.text(0.515, 0.963, 'Percentile Rank vs League Average '+pos,\n           fontproperties=reg, size=11, ha='center', color='#000000')\n\n  fig.text(0.17, 0.04, 'League Average', fontproperties=reg, size=10, color='#000000', va='center')\n\n  CREDIT_1 = 'Data: Lapangbola'\n  CREDIT_2 = komp+' | Season 2024/25 | Min. '+str(mins)+' mins played'\n\n  fig.text(0.515, 0.025, f'{CREDIT_1}\\n{CREDIT_2}', fontproperties=reg,\n           size=11, color='#000000', ha='center')\n\n  DC_to_FC = ax.transData.transform\n  FC_to_NFC = fig.transFigure.inverted().transform\n  DC_to_NFC = lambda x: FC_to_NFC(DC_to_FC(x))\n\n  logo_ax = fig.add_axes([0.73, 0.015, 0.15, 0.05], anchor = \"NE\")\n  club_icon = Image.open('logo2.png')\n  logo_ax.imshow(club_icon)\n  logo_ax.axis(\"off\")\n\n  fig.savefig('/content/gdrive/MyDrive/TSG 2024-25/Tim Nasional/Performance Radar/U23/pizza_'+name+'.jpg',\n              dpi=500, bbox_inches='tight', facecolor=fig.get_facecolor(), edgecolor='none')\n\n  return fig\n</code></pre>"}]}